document.addEventListener('DOMContentLoaded', () => {
    const inputTextArea = document.getElementById('input-text-area');
    const previewArea = document.getElementById('preview-area');
    const outputHtmlArea = document.getElementById('output-html-area');
    const generateButton = document.getElementById('generate-button');
    const copyButton = document.getElementById('copy-button');
    const copyMessage = document.getElementById('copy-message');

    // ★修正点1: inputイベントを監視し、リアルタイム変換を有効化
    inputTextArea.addEventListener('input', updateConversion);
    generateButton.addEventListener('click', updateConversion);

    copyButton.addEventListener('click', () => {
        const htmlContent = outputHtmlArea.value;
        navigator.clipboard.writeText(htmlContent).then(() => {
            copyMessage.textContent = 'コピーしました！';
            copyMessage.style.visibility = 'visible';
            setTimeout(() => { copyMessage.style.visibility = 'hidden'; }, 3000);
        }).catch(err => {
            copyMessage.textContent = 'コピー失敗。手動でコピーしてください。';
            copyMessage.style.visibility = 'visible';
            copyMessage.style.color = 'red';
            setTimeout(() => { copyMessage.style.visibility = 'hidden'; }, 5000);
        });
    });

    /**
     * 変換処理を実行し、UIを更新するメイン関数
     */
    function updateConversion() {
        const inputText = inputTextArea.value;
        const finalHtml = convertTextToHtml(inputText);
        
        // プレビューエリアにHTMLとして挿入（リアルタイムプレビュー）
        previewArea.innerHTML = finalHtml;
        
        // 出力エリアにHTMLコードとして挿入
        outputHtmlArea.value = finalHtml;
    }
    
    /**
     * 入力テキストをecbeing向けHTMLに変換します。
     */
    function convertTextToHtml(inputText) {
        const lines = inputText.split('\n');
        let finalHtmlLines = [];
        let currentParagraphLines = [];

        // 段落処理関数（太字・スペース・リンクの置換を含む）
        const processParagraph = () => {
            if (currentParagraphLines.length > 0) {
                // 処理済みの行を結合
                let processedParagraph = currentParagraphLines.map(line => {
                    let processedLine = line;

                    // 1. 太字の正規表現処理 (**)
                    // **太字** を <strong>太字</strong> に変換
                    processedLine = processedLine.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    
                    // 2. 固定スペースの正規表現処理 (___)
                    // ___ を &nbsp; (3つ) に変換
                    processedLine = processedLine.replace(/___/g, '&nbsp;&nbsp;&nbsp;');
                    
                    // 3. リンクの正規表現処理
                    // (表示テキスト 「URL」) または (表示テキスト 「URL」 別窓)
                    // ★修正点2: 正規表現をより頑健に修正
                    const linkPattern = /\((.+?)\s*「(https?:\/\/[^\s」]+?)」(別窓)?\)/g;
                    processedLine = processedLine.replace(linkPattern, (match, displayText, url, isNewWindow) => {
                        const targetAttr = isNewWindow ? ' target="_blank"' : '';
                        return `<a href="${url}"${targetAttr}>${displayText.trim()}</a>`;
                    });

                    return processedLine;
                }).join('<br>\n'); // 段落内の改行は <br> に変換

                finalHtmlLines.push(`<p>${processedParagraph}</p>\n`);
                currentParagraphLines = [];
            }
        };

        for (const line of lines) {
            const trimmedLine = line.trim();

            if (trimmedLine.startsWith('見出し:')) {
                processParagraph();
                const headingText = trimmedLine.replace('見出し:', '').trim();
                finalHtmlLines.push(`<h2>${headingText}</h2>`);
                finalHtmlLines.push('<hr>\n');
            } else if (trimmedLine.startsWith('小見出し:')) {
                processParagraph();
                const subheadingText = trimmedLine.replace('小見出し:', '').trim();
                finalHtmlLines.push(`<h3>${subheadingText}</h3>\n`);
            } else if (trimmedLine === '---') {
                processParagraph();
                finalHtmlLines.push('<hr>\n');
            } else if (trimmedLine === '') {
                processParagraph(); // 空行の場合、現在の段落を閉じる
            } else {
                // 通常のテキスト行として段落配列に追加
                currentParagraphLines.push(trimmedLine);
            }
        }

        // 最後に残っている段落があれば閉じる
        processParagraph();
        
        // 全体を囲むdiv
        return `<div class="article-body-v2">\n${finalHtmlLines.join('')}</div>`;
    }

    // 初期表示時に一度実行し、プレースホルダーの内容を変換
    updateConversion();
});