document.addEventListener('DOMContentLoaded', () => {
    const previewArea = document.getElementById('preview-area');
    const outputHtmlArea = document.getElementById('output-html-area');
    const copyButton = document.getElementById('copy-button');
    const copyMessage = document.getElementById('copy-message');

    // ★修正点1: Quillのツールバー定義を簡素化し、クラス名を確実に指定
    const toolbarOptions = [
        ['bold', 'italic'], 
        ['link'], 
        // カスタムボタンのクラス名リスト (CSSの.ql-XXXX:beforeと連携)
        ['customheading', 'customsubheading', 'customlink', 'customhr'] 
    ];

    // ★修正点2: Quillエディタの初期化とカスタムハンドラーの定義
    const quill = new Quill('#editor-container', {
        theme: 'snow',
        modules: {
            toolbar: {
                container: toolbarOptions,
                handlers: {
                    // ★重要★: カスタムボタンの動作を定義 (クラス名とすべて小文字で一致させる)
                    'customheading': () => insertCustomMarkup('見出し: ', 'heading'),
                    'customsubheading': () => insertCustomMarkup('小見出し: ', 'heading'),
                    'customlink': () => insertCustomMarkup(' (表示テキスト 「URL」 別窓)', 'link'),
                    'customhr': () => insertCustomMarkup('\n---\n', 'hr'),
                }
            }
        }
    });

    /**
     * カスタムマークアップを挿入または選択範囲を置換するヘルパー関数
     */
    function insertCustomMarkup(markup, type) {
        const range = quill.getSelection(true);
        if (!range) return;

        let selectedText = quill.getText(range.index, range.length).trim();
        let finalMarkup = '';

        if (type === 'heading') {
            const textToInsert = selectedText || 'ここにタイトルを記述';
            finalMarkup = markup + textToInsert;
            
            quill.deleteText(range.index, range.length, Quill.sources.USER);
            quill.insertText(range.index, finalMarkup, Quill.sources.USER);

        } else if (type === 'link') {
            const defaultText = selectedText || 'リンクテキスト';
            finalMarkup = ` (${defaultText} 「https://」 別窓)`;
            
            quill.deleteText(range.index, range.length, Quill.sources.USER);
            quill.insertText(range.index, finalMarkup, Quill.sources.USER);

        } else if (type === 'hr') {
            finalMarkup = markup;
            quill.insertText(range.index, finalMarkup, Quill.sources.USER);
        }
        
        quill.setSelection(range.index + finalMarkup.length, range.index + finalMarkup.length, Quill.sources.SILENT);
    }

    // テキスト変更イベントを監視し、リアルタイム変換を実行
    quill.on('text-change', () => {
        const inputText = quill.getText();
        updateConversion(inputText);
    });
    
    /**
     * 変換処理を実行し、UIを更新するメイン関数
     */
    function updateConversion(inputText) {
        const finalHtml = convertTextToHtml(inputText);
        
        previewArea.innerHTML = finalHtml;
        outputHtmlArea.value = finalHtml;
    }
    
    /**
     * 入力テキストをecbeing向けHTMLに変換します。（既存ロジック）
     */
    function convertTextToHtml(inputText) {
        const lines = inputText.split('\n');
        let finalHtmlLines = [];
        let currentParagraphLines = [];

        // 段落処理関数（太字・スペース・リンクの置換を含む）
        const processParagraph = () => {
            if (currentParagraphLines.length > 0) {
                let processedParagraph = currentParagraphLines.map(line => {
                    let processedLine = line.trim();

                    // 1. 太字の正規表現処理 (**)
                    processedLine = processedLine.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    
                    // 2. 固定スペースの正規表現処理 (___)
                    processedLine = processedLine.replace(/___/g, '&nbsp;&nbsp;&nbsp;');
                    
                    // 3. リンクの正規表現処理
                    const linkPattern = /\((.+?)\s*「(https?:\/\/[^\s」]+?)」(別窓)?\)/g;
                    processedLine = processedLine.replace(linkPattern, (match, displayText, url, isNewWindow) => {
                        const targetAttr = isNewWindow ? ' target="_blank"' : '';
                        return `<a href="${url.trim()}"${targetAttr}>${displayText.trim()}</a>`;
                    });

                    return processedLine;
                }).join('<br>\n');

                finalHtmlLines.push(`<p>${processedParagraph}</p>\n`);
                currentParagraphLines = [];
            }
        };

        for (const line of lines) {
            const trimmedLine = line.trim();

            if (trimmedLine.startsWith('見出し:')) {
                processParagraph();
                const headingText = trimmedLine.replace('見出し:', '').trim();
                finalHtmlLines.push(`<h2>${headingText}</h2>`);
                finalHtmlLines.push('<hr>\n');
            } else if (trimmedLine.startsWith('小見出し:')) {
                processParagraph();
                const subheadingText = trimmedLine.replace('小見出し:', '').trim();
                finalHtmlLines.push(`<h3>${subheadingText}</h3>\n`);
            } else if (trimmedLine === '---') {
                processParagraph();
                finalHtmlLines.push('<hr>\n');
            } else if (trimmedLine === '') {
                processParagraph();
            } else {
                // 通常のテキスト行として段落配列に追加 (行頭のスペースも保持するため、trimしない行をここで採用)
                currentParagraphLines.push(line); 
            }
        }

        processParagraph();
        
        return `<div class="article-body-v2">\n${finalHtmlLines.join('')}</div>`;
    }

    // 初期データの設定
    quill.setText("編集したいテキストをここに入力します。\n\nテキストを選択してから、上のツールバーボタンを押してください。\n\n**太字** や (リンク 「URL」 別窓) は、ボタンか直接入力で作成できます。\n\n---");
    updateConversion(quill.getText());

    // コピーボタンの処理
    copyButton.addEventListener('click', () => {
        const htmlContent = outputHtmlArea.value;
        navigator.clipboard.writeText(htmlContent).then(() => {
            copyMessage.textContent = 'コピーしました！';
            copyMessage.style.visibility = 'visible';
            setTimeout(() => { copyMessage.style.visibility = 'hidden'; }, 3000);
        }).catch(err => {
            copyMessage.textContent = 'コピー失敗。手動でコピーしてください。';
            copyMessage.style.visibility = 'visible';
            copyMessage.style.color = 'red';
            setTimeout(() => { copyMessage.style.visibility = 'hidden'; }, 5000);
        });
    });
});